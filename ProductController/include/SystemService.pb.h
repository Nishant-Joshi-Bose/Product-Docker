// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SoundTouchInterface/SystemService.proto

#ifndef PROTOBUF_SoundTouchInterface_2fSystemService_2eproto__INCLUDED
#define PROTOBUF_SoundTouchInterface_2fSystemService_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "ProtoToMarkup/MarkupOptions.pb.h"
#include "SoundTouchInterface/Status.pb.h"
#include "SoundTouchInterface/initializationcompleteaction.pb.h"
#include "SoundTouchInterface/ContentItem.pb.h"
// @@protoc_insertion_point(includes)

namespace SoundTouchInterface {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();

class CriticalError;
class criticalErrorUpdate;
class sysLanguage;
class name;
class reboot;
class SoundTouchConfigurationStatus;
class SerialNumber;
class SoftwareVersion;
class initializationCompleteRequest;
class initializationCompleteResponse;
class toggleStandbyRequest;
class toggleStandbyResponse;
class LowPowerStandbyUpdate;
class BluetoothInfo;

enum CriticalErrorType {
  ERROR_NONE = 0,
  ERROR_BATTERY_EXTREME_TEMP = 1,
  ERROR_BATTERY_PRECHARGE = 2,
  ERROR_AMP_FAULT = 3,
  ERROR_FACTORY_RESET = 4,
  ERROR_PRODUCT_UPDATE_REQUIRED = 5
};
bool CriticalErrorType_IsValid(int value);
const CriticalErrorType CriticalErrorType_MIN = ERROR_NONE;
const CriticalErrorType CriticalErrorType_MAX = ERROR_PRODUCT_UPDATE_REQUIRED;
const int CriticalErrorType_ARRAYSIZE = CriticalErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CriticalErrorType_descriptor();
inline const ::std::string& CriticalErrorType_Name(CriticalErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CriticalErrorType_descriptor(), value);
}
inline bool CriticalErrorType_Parse(
    const ::std::string& name, CriticalErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CriticalErrorType>(
    CriticalErrorType_descriptor(), name, value);
}
enum DisplayLanguage {
  DISPLAY_LANGUAGE_UNINITIALIZED = 0,
  DISPLAY_LANGUAGE_DANISH = 1,
  DISPLAY_LANGUAGE_GERMAN = 2,
  DISPLAY_LANGUAGE_ENGLISH = 3,
  DISPLAY_LANGUAGE_SPANISH = 4,
  DISPLAY_LANGUAGE_FRENCH = 5,
  DISPLAY_LANGUAGE_ITALIAN = 6,
  DISPLAY_LANGUAGE_DUTCH = 7,
  DISPLAY_LANGUAGE_SWEDISH = 8,
  DISPLAY_LANGUAGE_JAPANESE = 9,
  DISPLAY_LANGUAGE_SIMPLIFIED_CHINESE = 10,
  DISPLAY_LANGUAGE_TRADITIONAL_CHINESE = 11,
  DISPLAY_LANGUAGE_KOREAN = 12,
  DISPLAY_LANGUAGE_THAI = 13,
  DISPLAY_LANGUAGE_ARABIC = 14,
  DISPLAY_LANGUAGE_CZECH = 15,
  DISPLAY_LANGUAGE_FINNISH = 16,
  DISPLAY_LANGUAGE_GREEK = 17,
  DISPLAY_LANGUAGE_NORWEGIAN = 18,
  DISPLAY_LANGUAGE_POLISH = 19,
  DISPLAY_LANGUAGE_PORTUGUESE = 20,
  DISPLAY_LANGUAGE_ROMANIAN = 21,
  DISPLAY_LANGUAGE_RUSSIAN = 22,
  DISPLAY_LANGUAGE_SLOVENIAN = 23,
  DISPLAY_LANGUAGE_TURKISH = 24,
  DISPLAY_LANGUAGE_HUNGARIAN = 25,
  DISPLAY_LANGUAGE_LAST = 26
};
bool DisplayLanguage_IsValid(int value);
const DisplayLanguage DisplayLanguage_MIN = DISPLAY_LANGUAGE_UNINITIALIZED;
const DisplayLanguage DisplayLanguage_MAX = DISPLAY_LANGUAGE_LAST;
const int DisplayLanguage_ARRAYSIZE = DisplayLanguage_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayLanguage_descriptor();
inline const ::std::string& DisplayLanguage_Name(DisplayLanguage value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayLanguage_descriptor(), value);
}
inline bool DisplayLanguage_Parse(
    const ::std::string& name, DisplayLanguage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayLanguage>(
    DisplayLanguage_descriptor(), name, value);
}
enum SoundTouchConfigurationState {
  SOUNDTOUCH_CONFIGURED = 0,
  SOUNDTOUCH_NOT_CONFIGURED = 1,
  SOUNDTOUCH_CONFIGURING = 2
};
bool SoundTouchConfigurationState_IsValid(int value);
const SoundTouchConfigurationState SoundTouchConfigurationState_MIN = SOUNDTOUCH_CONFIGURED;
const SoundTouchConfigurationState SoundTouchConfigurationState_MAX = SOUNDTOUCH_CONFIGURING;
const int SoundTouchConfigurationState_ARRAYSIZE = SoundTouchConfigurationState_MAX + 1;

const ::google::protobuf::EnumDescriptor* SoundTouchConfigurationState_descriptor();
inline const ::std::string& SoundTouchConfigurationState_Name(SoundTouchConfigurationState value) {
  return ::google::protobuf::internal::NameOfEnum(
    SoundTouchConfigurationState_descriptor(), value);
}
inline bool SoundTouchConfigurationState_Parse(
    const ::std::string& name, SoundTouchConfigurationState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SoundTouchConfigurationState>(
    SoundTouchConfigurationState_descriptor(), name, value);
}
// ===================================================================

class CriticalError : public ::google::protobuf::Message {
 public:
  CriticalError();
  virtual ~CriticalError();
  
  CriticalError(const CriticalError& from);
  
  inline CriticalError& operator=(const CriticalError& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CriticalError& default_instance();
  
  void Swap(CriticalError* other);
  
  // implements Message ----------------------------------------------
  
  CriticalError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CriticalError& from);
  void MergeFrom(const CriticalError& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .SoundTouchInterface.CriticalErrorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline SoundTouchInterface::CriticalErrorType type() const;
  inline void set_type(SoundTouchInterface::CriticalErrorType value);
  
  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.CriticalError)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_desc();
  inline void clear_has_desc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* desc_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static CriticalError* default_instance_;
};
// -------------------------------------------------------------------

class criticalErrorUpdate : public ::google::protobuf::Message {
 public:
  criticalErrorUpdate();
  virtual ~criticalErrorUpdate();
  
  criticalErrorUpdate(const criticalErrorUpdate& from);
  
  inline criticalErrorUpdate& operator=(const criticalErrorUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const criticalErrorUpdate& default_instance();
  
  void Swap(criticalErrorUpdate* other);
  
  // implements Message ----------------------------------------------
  
  criticalErrorUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const criticalErrorUpdate& from);
  void MergeFrom(const criticalErrorUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string deviceID = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIDFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  
  // optional .SoundTouchInterface.CriticalError criticalError = 2;
  inline bool has_criticalerror() const;
  inline void clear_criticalerror();
  static const int kCriticalErrorFieldNumber = 2;
  inline const ::SoundTouchInterface::CriticalError& criticalerror() const;
  inline ::SoundTouchInterface::CriticalError* mutable_criticalerror();
  inline ::SoundTouchInterface::CriticalError* release_criticalerror();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.criticalErrorUpdate)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_criticalerror();
  inline void clear_has_criticalerror();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* deviceid_;
  ::SoundTouchInterface::CriticalError* criticalerror_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static criticalErrorUpdate* default_instance_;
};
// -------------------------------------------------------------------

class sysLanguage : public ::google::protobuf::Message {
 public:
  sysLanguage();
  virtual ~sysLanguage();
  
  sysLanguage(const sysLanguage& from);
  
  inline sysLanguage& operator=(const sysLanguage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const sysLanguage& default_instance();
  
  void Swap(sysLanguage* other);
  
  // implements Message ----------------------------------------------
  
  sysLanguage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sysLanguage& from);
  void MergeFrom(const sysLanguage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline ::google::protobuf::int32 text() const;
  inline void set_text(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.sysLanguage)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static sysLanguage* default_instance_;
};
// -------------------------------------------------------------------

class name : public ::google::protobuf::Message {
 public:
  name();
  virtual ~name();
  
  name(const name& from);
  
  inline name& operator=(const name& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const name& default_instance();
  
  void Swap(name* other);
  
  // implements Message ----------------------------------------------
  
  name* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const name& from);
  void MergeFrom(const name& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.name)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static name* default_instance_;
};
// -------------------------------------------------------------------

class reboot : public ::google::protobuf::Message {
 public:
  reboot();
  virtual ~reboot();
  
  reboot(const reboot& from);
  
  inline reboot& operator=(const reboot& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const reboot& default_instance();
  
  void Swap(reboot* other);
  
  // implements Message ----------------------------------------------
  
  reboot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reboot& from);
  void MergeFrom(const reboot& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.reboot)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static reboot* default_instance_;
};
// -------------------------------------------------------------------

class SoundTouchConfigurationStatus : public ::google::protobuf::Message {
 public:
  SoundTouchConfigurationStatus();
  virtual ~SoundTouchConfigurationStatus();
  
  SoundTouchConfigurationStatus(const SoundTouchConfigurationStatus& from);
  
  inline SoundTouchConfigurationStatus& operator=(const SoundTouchConfigurationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SoundTouchConfigurationStatus& default_instance();
  
  void Swap(SoundTouchConfigurationStatus* other);
  
  // implements Message ----------------------------------------------
  
  SoundTouchConfigurationStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoundTouchConfigurationStatus& from);
  void MergeFrom(const SoundTouchConfigurationStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .SoundTouchInterface.SoundTouchConfigurationState status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline SoundTouchInterface::SoundTouchConfigurationState status() const;
  inline void set_status(SoundTouchInterface::SoundTouchConfigurationState value);
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.SoundTouchConfigurationStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static SoundTouchConfigurationStatus* default_instance_;
};
// -------------------------------------------------------------------

class SerialNumber : public ::google::protobuf::Message {
 public:
  SerialNumber();
  virtual ~SerialNumber();
  
  SerialNumber(const SerialNumber& from);
  
  inline SerialNumber& operator=(const SerialNumber& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialNumber& default_instance();
  
  void Swap(SerialNumber* other);
  
  // implements Message ----------------------------------------------
  
  SerialNumber* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialNumber& from);
  void MergeFrom(const SerialNumber& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string serialNumber = 1;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 1;
  inline const ::std::string& serialnumber() const;
  inline void set_serialnumber(const ::std::string& value);
  inline void set_serialnumber(const char* value);
  inline void set_serialnumber(const char* value, size_t size);
  inline ::std::string* mutable_serialnumber();
  inline ::std::string* release_serialnumber();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.SerialNumber)
 private:
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* serialnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static SerialNumber* default_instance_;
};
// -------------------------------------------------------------------

class SoftwareVersion : public ::google::protobuf::Message {
 public:
  SoftwareVersion();
  virtual ~SoftwareVersion();
  
  SoftwareVersion(const SoftwareVersion& from);
  
  inline SoftwareVersion& operator=(const SoftwareVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftwareVersion& default_instance();
  
  void Swap(SoftwareVersion* other);
  
  // implements Message ----------------------------------------------
  
  SoftwareVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftwareVersion& from);
  void MergeFrom(const SoftwareVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string softwareVersion = 1;
  inline bool has_softwareversion() const;
  inline void clear_softwareversion();
  static const int kSoftwareVersionFieldNumber = 1;
  inline const ::std::string& softwareversion() const;
  inline void set_softwareversion(const ::std::string& value);
  inline void set_softwareversion(const char* value);
  inline void set_softwareversion(const char* value, size_t size);
  inline ::std::string* mutable_softwareversion();
  inline ::std::string* release_softwareversion();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.SoftwareVersion)
 private:
  inline void set_has_softwareversion();
  inline void clear_has_softwareversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* softwareversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static SoftwareVersion* default_instance_;
};
// -------------------------------------------------------------------

class initializationCompleteRequest : public ::google::protobuf::Message {
 public:
  initializationCompleteRequest();
  virtual ~initializationCompleteRequest();
  
  initializationCompleteRequest(const initializationCompleteRequest& from);
  
  inline initializationCompleteRequest& operator=(const initializationCompleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const initializationCompleteRequest& default_instance();
  
  void Swap(initializationCompleteRequest* other);
  
  // implements Message ----------------------------------------------
  
  initializationCompleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const initializationCompleteRequest& from);
  void MergeFrom(const initializationCompleteRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool update = 1;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 1;
  inline bool update() const;
  inline void set_update(bool value);
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.initializationCompleteRequest)
 private:
  inline void set_has_update();
  inline void clear_has_update();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool update_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static initializationCompleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class initializationCompleteResponse : public ::google::protobuf::Message {
 public:
  initializationCompleteResponse();
  virtual ~initializationCompleteResponse();
  
  initializationCompleteResponse(const initializationCompleteResponse& from);
  
  inline initializationCompleteResponse& operator=(const initializationCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const initializationCompleteResponse& default_instance();
  
  void Swap(initializationCompleteResponse* other);
  
  // implements Message ----------------------------------------------
  
  initializationCompleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const initializationCompleteResponse& from);
  void MergeFrom(const initializationCompleteResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .SoundTouchInterface.sourceAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline SoundTouchInterface::sourceAction action() const;
  inline void set_action(SoundTouchInterface::sourceAction value);
  
  // optional .SoundTouchInterface.ContentItem contentItem = 2;
  inline bool has_contentitem() const;
  inline void clear_contentitem();
  static const int kContentItemFieldNumber = 2;
  inline const ::SoundTouchInterface::ContentItem& contentitem() const;
  inline ::SoundTouchInterface::ContentItem* mutable_contentitem();
  inline ::SoundTouchInterface::ContentItem* release_contentitem();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.initializationCompleteResponse)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_contentitem();
  inline void clear_has_contentitem();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::SoundTouchInterface::ContentItem* contentitem_;
  int action_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static initializationCompleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class toggleStandbyRequest : public ::google::protobuf::Message {
 public:
  toggleStandbyRequest();
  virtual ~toggleStandbyRequest();
  
  toggleStandbyRequest(const toggleStandbyRequest& from);
  
  inline toggleStandbyRequest& operator=(const toggleStandbyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const toggleStandbyRequest& default_instance();
  
  void Swap(toggleStandbyRequest* other);
  
  // implements Message ----------------------------------------------
  
  toggleStandbyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const toggleStandbyRequest& from);
  void MergeFrom(const toggleStandbyRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.toggleStandbyRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static toggleStandbyRequest* default_instance_;
};
// -------------------------------------------------------------------

class toggleStandbyResponse : public ::google::protobuf::Message {
 public:
  toggleStandbyResponse();
  virtual ~toggleStandbyResponse();
  
  toggleStandbyResponse(const toggleStandbyResponse& from);
  
  inline toggleStandbyResponse& operator=(const toggleStandbyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const toggleStandbyResponse& default_instance();
  
  void Swap(toggleStandbyResponse* other);
  
  // implements Message ----------------------------------------------
  
  toggleStandbyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const toggleStandbyResponse& from);
  void MergeFrom(const toggleStandbyResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.toggleStandbyResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static toggleStandbyResponse* default_instance_;
};
// -------------------------------------------------------------------

class LowPowerStandbyUpdate : public ::google::protobuf::Message {
 public:
  LowPowerStandbyUpdate();
  virtual ~LowPowerStandbyUpdate();
  
  LowPowerStandbyUpdate(const LowPowerStandbyUpdate& from);
  
  inline LowPowerStandbyUpdate& operator=(const LowPowerStandbyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LowPowerStandbyUpdate& default_instance();
  
  void Swap(LowPowerStandbyUpdate* other);
  
  // implements Message ----------------------------------------------
  
  LowPowerStandbyUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LowPowerStandbyUpdate& from);
  void MergeFrom(const LowPowerStandbyUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string deviceID = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIDFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.LowPowerStandbyUpdate)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* deviceid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static LowPowerStandbyUpdate* default_instance_;
};
// -------------------------------------------------------------------

class BluetoothInfo : public ::google::protobuf::Message {
 public:
  BluetoothInfo();
  virtual ~BluetoothInfo();
  
  BluetoothInfo(const BluetoothInfo& from);
  
  inline BluetoothInfo& operator=(const BluetoothInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BluetoothInfo& default_instance();
  
  void Swap(BluetoothInfo* other);
  
  // implements Message ----------------------------------------------
  
  BluetoothInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BluetoothInfo& from);
  void MergeFrom(const BluetoothInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string BluetoothMACAddress = 1;
  inline bool has_bluetoothmacaddress() const;
  inline void clear_bluetoothmacaddress();
  static const int kBluetoothMACAddressFieldNumber = 1;
  inline const ::std::string& bluetoothmacaddress() const;
  inline void set_bluetoothmacaddress(const ::std::string& value);
  inline void set_bluetoothmacaddress(const char* value);
  inline void set_bluetoothmacaddress(const char* value, size_t size);
  inline ::std::string* mutable_bluetoothmacaddress();
  inline ::std::string* release_bluetoothmacaddress();
  
  // optional int32 NumberOfPairedDevices = 2;
  inline bool has_numberofpaireddevices() const;
  inline void clear_numberofpaireddevices();
  static const int kNumberOfPairedDevicesFieldNumber = 2;
  inline ::google::protobuf::int32 numberofpaireddevices() const;
  inline void set_numberofpaireddevices(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SoundTouchInterface.BluetoothInfo)
 private:
  inline void set_has_bluetoothmacaddress();
  inline void clear_has_bluetoothmacaddress();
  inline void set_has_numberofpaireddevices();
  inline void clear_has_numberofpaireddevices();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bluetoothmacaddress_;
  ::google::protobuf::int32 numberofpaireddevices_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_AssignDesc_SoundTouchInterface_2fSystemService_2eproto();
  friend void protobuf_ShutdownFile_SoundTouchInterface_2fSystemService_2eproto();
  
  void InitAsDefaultInstance();
  static BluetoothInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// CriticalError

// optional .SoundTouchInterface.CriticalErrorType type = 1;
inline bool CriticalError::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CriticalError::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CriticalError::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CriticalError::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline SoundTouchInterface::CriticalErrorType CriticalError::type() const {
  return static_cast< SoundTouchInterface::CriticalErrorType >(type_);
}
inline void CriticalError::set_type(SoundTouchInterface::CriticalErrorType value) {
  GOOGLE_DCHECK(SoundTouchInterface::CriticalErrorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string desc = 2;
inline bool CriticalError::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CriticalError::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CriticalError::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CriticalError::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& CriticalError::desc() const {
  return *desc_;
}
inline void CriticalError::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CriticalError::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void CriticalError::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CriticalError::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* CriticalError::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// criticalErrorUpdate

// required string deviceID = 1;
inline bool criticalErrorUpdate::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void criticalErrorUpdate::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void criticalErrorUpdate::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void criticalErrorUpdate::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& criticalErrorUpdate::deviceid() const {
  return *deviceid_;
}
inline void criticalErrorUpdate::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void criticalErrorUpdate::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void criticalErrorUpdate::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* criticalErrorUpdate::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* criticalErrorUpdate::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .SoundTouchInterface.CriticalError criticalError = 2;
inline bool criticalErrorUpdate::has_criticalerror() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void criticalErrorUpdate::set_has_criticalerror() {
  _has_bits_[0] |= 0x00000002u;
}
inline void criticalErrorUpdate::clear_has_criticalerror() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void criticalErrorUpdate::clear_criticalerror() {
  if (criticalerror_ != NULL) criticalerror_->::SoundTouchInterface::CriticalError::Clear();
  clear_has_criticalerror();
}
inline const ::SoundTouchInterface::CriticalError& criticalErrorUpdate::criticalerror() const {
  return criticalerror_ != NULL ? *criticalerror_ : *default_instance_->criticalerror_;
}
inline ::SoundTouchInterface::CriticalError* criticalErrorUpdate::mutable_criticalerror() {
  set_has_criticalerror();
  if (criticalerror_ == NULL) criticalerror_ = new ::SoundTouchInterface::CriticalError;
  return criticalerror_;
}
inline ::SoundTouchInterface::CriticalError* criticalErrorUpdate::release_criticalerror() {
  clear_has_criticalerror();
  ::SoundTouchInterface::CriticalError* temp = criticalerror_;
  criticalerror_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// sysLanguage

// optional int32 text = 1;
inline bool sysLanguage::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sysLanguage::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sysLanguage::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sysLanguage::clear_text() {
  text_ = 0;
  clear_has_text();
}
inline ::google::protobuf::int32 sysLanguage::text() const {
  return text_;
}
inline void sysLanguage::set_text(::google::protobuf::int32 value) {
  set_has_text();
  text_ = value;
}

// -------------------------------------------------------------------

// name

// optional string text = 1;
inline bool name::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void name::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void name::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void name::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& name::text() const {
  return *text_;
}
inline void name::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void name::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void name::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* name::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* name::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// reboot

// -------------------------------------------------------------------

// SoundTouchConfigurationStatus

// optional .SoundTouchInterface.SoundTouchConfigurationState status = 1;
inline bool SoundTouchConfigurationStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoundTouchConfigurationStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoundTouchConfigurationStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoundTouchConfigurationStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline SoundTouchInterface::SoundTouchConfigurationState SoundTouchConfigurationStatus::status() const {
  return static_cast< SoundTouchInterface::SoundTouchConfigurationState >(status_);
}
inline void SoundTouchConfigurationStatus::set_status(SoundTouchInterface::SoundTouchConfigurationState value) {
  GOOGLE_DCHECK(SoundTouchInterface::SoundTouchConfigurationState_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SerialNumber

// optional string serialNumber = 1;
inline bool SerialNumber::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SerialNumber::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SerialNumber::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SerialNumber::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& SerialNumber::serialnumber() const {
  return *serialnumber_;
}
inline void SerialNumber::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void SerialNumber::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void SerialNumber::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerialNumber::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* SerialNumber::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SoftwareVersion

// optional string softwareVersion = 1;
inline bool SoftwareVersion::has_softwareversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftwareVersion::set_has_softwareversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftwareVersion::clear_has_softwareversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftwareVersion::clear_softwareversion() {
  if (softwareversion_ != &::google::protobuf::internal::kEmptyString) {
    softwareversion_->clear();
  }
  clear_has_softwareversion();
}
inline const ::std::string& SoftwareVersion::softwareversion() const {
  return *softwareversion_;
}
inline void SoftwareVersion::set_softwareversion(const ::std::string& value) {
  set_has_softwareversion();
  if (softwareversion_ == &::google::protobuf::internal::kEmptyString) {
    softwareversion_ = new ::std::string;
  }
  softwareversion_->assign(value);
}
inline void SoftwareVersion::set_softwareversion(const char* value) {
  set_has_softwareversion();
  if (softwareversion_ == &::google::protobuf::internal::kEmptyString) {
    softwareversion_ = new ::std::string;
  }
  softwareversion_->assign(value);
}
inline void SoftwareVersion::set_softwareversion(const char* value, size_t size) {
  set_has_softwareversion();
  if (softwareversion_ == &::google::protobuf::internal::kEmptyString) {
    softwareversion_ = new ::std::string;
  }
  softwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SoftwareVersion::mutable_softwareversion() {
  set_has_softwareversion();
  if (softwareversion_ == &::google::protobuf::internal::kEmptyString) {
    softwareversion_ = new ::std::string;
  }
  return softwareversion_;
}
inline ::std::string* SoftwareVersion::release_softwareversion() {
  clear_has_softwareversion();
  if (softwareversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = softwareversion_;
    softwareversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// initializationCompleteRequest

// optional bool update = 1;
inline bool initializationCompleteRequest::has_update() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void initializationCompleteRequest::set_has_update() {
  _has_bits_[0] |= 0x00000001u;
}
inline void initializationCompleteRequest::clear_has_update() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void initializationCompleteRequest::clear_update() {
  update_ = false;
  clear_has_update();
}
inline bool initializationCompleteRequest::update() const {
  return update_;
}
inline void initializationCompleteRequest::set_update(bool value) {
  set_has_update();
  update_ = value;
}

// -------------------------------------------------------------------

// initializationCompleteResponse

// optional .SoundTouchInterface.sourceAction action = 1;
inline bool initializationCompleteResponse::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void initializationCompleteResponse::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void initializationCompleteResponse::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void initializationCompleteResponse::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline SoundTouchInterface::sourceAction initializationCompleteResponse::action() const {
  return static_cast< SoundTouchInterface::sourceAction >(action_);
}
inline void initializationCompleteResponse::set_action(SoundTouchInterface::sourceAction value) {
  GOOGLE_DCHECK(SoundTouchInterface::sourceAction_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional .SoundTouchInterface.ContentItem contentItem = 2;
inline bool initializationCompleteResponse::has_contentitem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void initializationCompleteResponse::set_has_contentitem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void initializationCompleteResponse::clear_has_contentitem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void initializationCompleteResponse::clear_contentitem() {
  if (contentitem_ != NULL) contentitem_->::SoundTouchInterface::ContentItem::Clear();
  clear_has_contentitem();
}
inline const ::SoundTouchInterface::ContentItem& initializationCompleteResponse::contentitem() const {
  return contentitem_ != NULL ? *contentitem_ : *default_instance_->contentitem_;
}
inline ::SoundTouchInterface::ContentItem* initializationCompleteResponse::mutable_contentitem() {
  set_has_contentitem();
  if (contentitem_ == NULL) contentitem_ = new ::SoundTouchInterface::ContentItem;
  return contentitem_;
}
inline ::SoundTouchInterface::ContentItem* initializationCompleteResponse::release_contentitem() {
  clear_has_contentitem();
  ::SoundTouchInterface::ContentItem* temp = contentitem_;
  contentitem_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// toggleStandbyRequest

// -------------------------------------------------------------------

// toggleStandbyResponse

// optional bool status = 1;
inline bool toggleStandbyResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void toggleStandbyResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void toggleStandbyResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void toggleStandbyResponse::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool toggleStandbyResponse::status() const {
  return status_;
}
inline void toggleStandbyResponse::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// LowPowerStandbyUpdate

// required string deviceID = 1;
inline bool LowPowerStandbyUpdate::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LowPowerStandbyUpdate::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LowPowerStandbyUpdate::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LowPowerStandbyUpdate::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LowPowerStandbyUpdate::deviceid() const {
  return *deviceid_;
}
inline void LowPowerStandbyUpdate::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LowPowerStandbyUpdate::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LowPowerStandbyUpdate::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LowPowerStandbyUpdate::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LowPowerStandbyUpdate::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BluetoothInfo

// optional string BluetoothMACAddress = 1;
inline bool BluetoothInfo::has_bluetoothmacaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BluetoothInfo::set_has_bluetoothmacaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BluetoothInfo::clear_has_bluetoothmacaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BluetoothInfo::clear_bluetoothmacaddress() {
  if (bluetoothmacaddress_ != &::google::protobuf::internal::kEmptyString) {
    bluetoothmacaddress_->clear();
  }
  clear_has_bluetoothmacaddress();
}
inline const ::std::string& BluetoothInfo::bluetoothmacaddress() const {
  return *bluetoothmacaddress_;
}
inline void BluetoothInfo::set_bluetoothmacaddress(const ::std::string& value) {
  set_has_bluetoothmacaddress();
  if (bluetoothmacaddress_ == &::google::protobuf::internal::kEmptyString) {
    bluetoothmacaddress_ = new ::std::string;
  }
  bluetoothmacaddress_->assign(value);
}
inline void BluetoothInfo::set_bluetoothmacaddress(const char* value) {
  set_has_bluetoothmacaddress();
  if (bluetoothmacaddress_ == &::google::protobuf::internal::kEmptyString) {
    bluetoothmacaddress_ = new ::std::string;
  }
  bluetoothmacaddress_->assign(value);
}
inline void BluetoothInfo::set_bluetoothmacaddress(const char* value, size_t size) {
  set_has_bluetoothmacaddress();
  if (bluetoothmacaddress_ == &::google::protobuf::internal::kEmptyString) {
    bluetoothmacaddress_ = new ::std::string;
  }
  bluetoothmacaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BluetoothInfo::mutable_bluetoothmacaddress() {
  set_has_bluetoothmacaddress();
  if (bluetoothmacaddress_ == &::google::protobuf::internal::kEmptyString) {
    bluetoothmacaddress_ = new ::std::string;
  }
  return bluetoothmacaddress_;
}
inline ::std::string* BluetoothInfo::release_bluetoothmacaddress() {
  clear_has_bluetoothmacaddress();
  if (bluetoothmacaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bluetoothmacaddress_;
    bluetoothmacaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 NumberOfPairedDevices = 2;
inline bool BluetoothInfo::has_numberofpaireddevices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BluetoothInfo::set_has_numberofpaireddevices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BluetoothInfo::clear_has_numberofpaireddevices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BluetoothInfo::clear_numberofpaireddevices() {
  numberofpaireddevices_ = 0;
  clear_has_numberofpaireddevices();
}
inline ::google::protobuf::int32 BluetoothInfo::numberofpaireddevices() const {
  return numberofpaireddevices_;
}
inline void BluetoothInfo::set_numberofpaireddevices(::google::protobuf::int32 value) {
  set_has_numberofpaireddevices();
  numberofpaireddevices_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SoundTouchInterface

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< SoundTouchInterface::CriticalErrorType>() {
  return SoundTouchInterface::CriticalErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< SoundTouchInterface::DisplayLanguage>() {
  return SoundTouchInterface::DisplayLanguage_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< SoundTouchInterface::SoundTouchConfigurationState>() {
  return SoundTouchInterface::SoundTouchConfigurationState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SoundTouchInterface_2fSystemService_2eproto__INCLUDED
