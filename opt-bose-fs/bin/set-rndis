#!/usr/bin/python2.7
#
# Enable or disable RNDIS mode.
#
# usage:
# set-rndis           -- tell whether dual RNDIS/ADB mode is enabled
# set-rndis off       -- disable RNDIS mode, enable ADB
# set-rndis on        -- enable simultaneous RNDIS and ADB
#
import os
import sys
import subprocess

script_name = "/etc/launch_adbd"
script = open(script_name).read()

enabled = "/sbin/usb/compositions/9059 n 2"
disabled = "/sbin/usb/compositions/901D n"

this_script = os.path.basename(sys.argv.pop(0))

if len(sys.argv) == 0:
    if disabled in script:
        print "disabled"
    elif enabled in script:
        print "enabled"
    else:
        print "unknown"
    sys.exit()

if len(sys.argv) == 1 and sys.argv[0] == "on":
    old, new = disabled, enabled
elif len(sys.argv) == 1 and sys.argv[0] == "off":
    old, new = enabled, disabled
else:
    sys.exit("usage: {} [on|off]".format(this_script))

if new in script:
    #print "unchanged"
    sys.exit()

i = script.find(old)
if i == -1:
    sys.exit("{}: not enabled and not disabled?".format(this_script))

remount = False
if not os.access(script_name, os.W_OK):
    remount = True
    subprocess.call(["mount", "-oremount,rw", "/"])

with open(script_name, "w") as fh:
    fh.write(script[:i] + new + script[i+len(old):])
print "{}: wrote {}".format(this_script, script_name)

if remount:
    subprocess.call(["mount", "-oremount,ro", "/"])

# If we're running via `adb shell`, we're going to get a SIGHUP when we run
# this next command.  We use `setsid` to ensure the SIGHUP isn't delivered to
# the command (so the command is allowed to finish).  Also we discard stdout
# and stderr otherwise the command would get a SIGPIPE if it tried to generate
# any output.

print "{}: running {}".format(this_script, new)
devnull = open(os.devnull, 'w')
subprocess.call(['setsid'] + new.split(), stdout=devnull, stderr=devnull)

sys.exit()
