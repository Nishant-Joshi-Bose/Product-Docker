#!/usr/bin/python2.7
#
# Invoked by PtsServer for each HTTP client connection.
# HTTP request headers and payload are to be read from stdin.
# HTTP response headers and payload are to be written to stdout.
#
import os
import sys
import subprocess

debug = False

def log(*args):
    print >>sys.stderr, "pts-handler:", " ".join(map(lambda a: str(a), args))

if len(sys.argv) != 1:
    raise Exception("wrong usage " + str(sys.argv))

# ----------------------------------------------------------------------------

line = sys.stdin.readline()
if not line:
    if debug:
        log("No header")
    sys.exit()

# `line` is like: "GET /hello/world.zip HTTP/1.1\r\n"
line = line.rstrip("\r\n")
fields = line.split(" ")
if len(fields) != 3:
    log("Malformed first header line", repr(fields))
    sys.exit()
method, path, version = fields

if debug:
    log("method '{}', path '{}', version '{}'".format(method, path, version))

# ----------------------------------------------------------------------------

# Read the HTTP headers
while True:
    line = sys.stdin.readline()
    if not line:
        if debug:
            log("EOF")
        sys.exit()
    line = line.rstrip("\r\n")
    if line == "":
        break
    if debug:
        log("header '{}'".format(line))

# ----------------------------------------------------------------------------

def http_ok(content_type="text/plain"):
    print """\
HTTP/1.1 200 OK\r
Content-Type: {}\r
Cache-Control: no-cache\r
\r""".format(content_type)

def http_err(code="404 Not Found"):
    print """\
HTTP/1.1 {code}\r
Content-Type: text/plain\r
\r
{code}\r""".format(code=code)

def only_for_usb():
    iface = os.environ.get("IFACE", "")
    if iface.startswith("usb"):
        return
    if iface.startswith("rndis"):
        return
    if iface == "lo":           # for testing; see `adb forward`
        return
    log("Attempt to access {} via interface {}".format(path, iface))
    if os.path.exists("/mnt/nv/product-persistence/anyiface"):
        return
    http_err()
    sys.exit()

if method == "GET":

# ----------------------------------------------------------------------------
# Diagnostics CGI pages.

    if path == "/diag":
        print """\
HTTP/1.1 301 Moved Permanently\r
Location: /diag/\r
\r
Moved Permanently\r
"""
        sys.exit()

    if path.startswith("/diag/"):
        only_for_usb()

        path = path[len("/diag/"):]
        if path == "":
            path = "main"
        prog = path
        args = []
        i = path.find("/")
        if i != -1:
            args.append(path[i+1:])
            prog = path[:i]
        log("diag", prog, args)
        os.chdir("/opt/Bose/diag")
        sys.stdout.flush()
        os.execv(prog, [prog] + args)

# ----------------------------------------------------------------------------

    if path == "/logread.txt":
        only_for_usb()

        http_ok()
        sys.stdout.flush()
        os.execl("/sbin/logread", "logread")

# ----------------------------------------------------------------------------

    if path == "/logread.txt.gz":
        only_for_usb()

        http_ok("application/x-gzip")
        sys.stdout.flush()
        os.execl("/bin/sh", "sh", "-c", "logread | gzip")

# ----------------------------------------------------------------------------

    if path == "/pts.txt":
        only_for_usb()

        def call(*args):
            print ">", " ".join(args)
            sys.stdout.flush()
            subprocess.call(args)

        http_ok()
        os.dup2(sys.stdout.fileno(), sys.stderr.fileno()) # redirect stderr to stdout
        call("date")
        call("cat", "/opt/Bose/etc/BoseVersion.json")
        call("free", "-m")
        call("ifconfig", "-a")
        call("ip", "route", "list")
        call("wpa_cli", "status")
        call("wpa_cli", "scan_results")
        call("sh", "-c", "head -20 /mnt/nv/product-persistence/*")
        call("ls", "-lHt", "/mnt/nv/BoseLog")
        call("ps")
        sys.exit()

# ----------------------------------------------------------------------------
# Force the system into reflash mode (QFIL).

    if path == "/reflash":
        only_for_usb()

        http_ok("text/html")
        print """\
<html>
<head>
<title>Reflash Mode</title>
<style type="text/css">
 body {
   font-family: Verdana, Arial, Helvetica, sans-serif;
 }
</style>
</head>
<body>
<h1>Entering Reflash Mode</h1>
<p>Please wait.
</body>
</html>
"""
        sys.stdout.flush()

        # Sleep to give the output a chance to get out.
        subprocess.call("""(
  exec >&2;
  sleep 3;
  PlatformResetIntoQfil
) &""", shell=True)
        sys.exit()

# ----------------------------------------------------------------------------
# Get Bose version.

    if path == "/bose-version":
        only_for_usb()

        http_ok()
        sys.stdout.write(open("/opt/Bose/etc/BoseVersion.json").read())
        sys.exit()

# ----------------------------------------------------------------------------
# Get Riviera version.

    if path == "/kernel-version":
        only_for_usb()

        http_ok()
        sys.stdout.write(open("/etc/riviera-version").read())
        sys.exit()

# ----------------------------------------------------------------------------
# Validate manufacturing data.

    if path == "/validate-mfgdata":
        only_for_usb()

        http_ok()
        os.dup2(sys.stdout.fileno(), sys.stderr.fileno()) # redirect stderr to stdout
        sys.stdout.flush()
        if subprocess.call(["/opt/Bose/bin/validate-mfgdata"]) == 0:
            print "Valid Manufacturing Data."
        else:
            print "Invalid Manufacturing Data."
        sys.exit()

# ----------------------------------------------------------------------------
# Open source license documents.
# The customer end-user documentation references this URL path.

    path_lower = path.lower()
    if path_lower == "/opensource" or path_lower == "/opensource/":
        print """\
HTTP/1.1 301 Moved Permanently\r
Location: /licenses.txt\r
\r
Moved Permanently\r
"""
        sys.exit()

# ----------------------------------------------------------------------------
# Serve static content.

    # Discard any query parameters from paths like
    # "/index.html?deeplink=com.bose.myApp&ssid=myNetwork&context=ApSetup".
    # See https://github.com/BoseCorp/bose-web-riviera-ap-page/
    i = path.find("?")
    if i != -1:
        path = path[:i]

    if path == "/":
        path = "/index.html"
    file_name = "/opt/Bose/html" + path

    # Avoid possible security issues with paths like ../../etc/passwd and symlinks.
    if file_name != os.path.realpath(file_name):
        http_err()
        sys.exit()

    content_types = {
        ".jpg": "image/jpeg",
        ".pdf": "application/pdf",
        ".svg": "image/svg+xml",
    }
    content_type = "text/plain"
    for ext, ctype in content_types.iteritems():
        if file_name.endswith(ext):
            content_type = ctype
            break

    try:
        with open(file_name) as fh:
            http_ok(content_type)

            while True:
                buf = fh.read(4096)
                if not buf:
                    break
                sys.stdout.write(buf)
        log("Sent {} ({})".format(file_name, content_type))
    except IOError, exc:
        log("open " + file_name + ": " + exc.strerror)
        http_err()
    sys.exit()

# ----------------------------------------------------------------------------

http_err()
