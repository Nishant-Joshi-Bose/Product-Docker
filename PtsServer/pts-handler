#!/usr/bin/python2.7
#
# Invoked by PtsServer for each HTTP client connection.
# HTTP request headers and payload are to be read from stdin.
# HTTP response headers and payload are to be written to stdout.
#
import os
import sys
import subprocess

debug = False

def log(*args):
    print >>sys.stderr, "pts-handler:", " ".join(map(lambda a: str(a), args))

if len(sys.argv) != 1:
    raise Exception("wrong usage " + str(sys.argv))

# ----------------------------------------------------------------------------

line = sys.stdin.readline()
if not line:
    if debug:
        log("No header")
    sys.exit()

# `line` is like: "GET /hello/world.zip HTTP/1.1\r\n"
line = line.rstrip("\r\n")
fields = line.split(" ")
if len(fields) != 3:
    log("Malformed first header line", repr(fields))
    sys.exit()
method, path, version = fields

if debug:
    log("method '{}', path '{}', version '{}'".format(method, path, version))

# ----------------------------------------------------------------------------

# Read the HTTP headers
while True:
    line = sys.stdin.readline()
    if not line:
        if debug:
            log("EOF")
        sys.exit()
    line = line.rstrip("\r\n")
    if line == "":
        break
    if debug:
        log("header '{}'".format(line))

# ----------------------------------------------------------------------------

def http_ok(content_type="text/plain"):
    print """\
HTTP/1.1 200 OK\r
Content-Type: {}\r
Cache-Control: no-cache\r
\r""".format(content_type)

def http_err(code="404 Not Found"):
    print """\
HTTP/1.1 {code}\r
Content-Type: text/plain\r
\r
{code}\r""".format(code=code)

usb_ifaces = ["usb*", "rndis*"]

def http_redirect(actual_path, from_path, to_path):
    if actual_path == from_path:
        print """\
HTTP/1.1 301 Moved Permanently\r
Location: {}\r
\r
Moved Permanently\r
""".format(to_path)
        sys.exit()

def only_for_usb():
    only_for_ifaces(usb_ifaces)

def only_for_ifaces(allowed_ifaces):
    iface = os.environ.get("IFACE", "")
    if iface == "lo": # loopback is always considered safe
        return
    for allowed_iface in allowed_ifaces:
        if allowed_iface.endswith("*"):
            if iface.startswith(allowed_iface[:-1]):
                return
        else:
            if iface == allowed_iface:
                return
    log("Attempt to access {} via interface {}".format(path, iface))
    if os.path.exists("/mnt/nv/product-persistence/anyiface"):
        return
    http_err()
    sys.exit()

def redirect_stderr():
    # Redirect stderr to stdout
    os.dup2(sys.stdout.fileno(), sys.stderr.fileno())
    sys.stdout.flush()

def is_development():
    return 0 == subprocess.call(["is-development"])

# ----------------------------------------------------------------------------

if method != "GET":
    http_err()

# ----------------------------------------------------------------------------
# A way to download Spotify audio data dump files
if path == "/audio.tar" and is_development():
    http_ok("application/octet-stream")
    sys.stdout.flush()
    # When the system is in development mode Spotify outputs the OGG Vorbis
    # audio data files /tmp/spotify-<url id>-<timestamp>.ogg
    # This can also be enabled with the tap command "spotify debug out"
    os.execl("/bin/sh", "sh", "-c", "/bin/tar -c /tmp/spotify*.ogg")

# ----------------------------------------------------------------------------
# Diagnostics pages.

http_redirect(path, "/diag", "/diag/")

if path.startswith("/diag/"):
    only_for_usb()

    path = path[len("/diag/"):]
    if path == "":
        path = "main"
    prog = path
    args = []
    i = path.find("/")
    if i != -1:
        args.append(path[i+1:])
        prog = path[:i]
    log("diag", prog, args)
    os.chdir("/opt/Bose/diag")
    sys.stdout.flush()
    os.execv(prog, [prog] + args)

# ----------------------------------------------------------------------------
# View the log message buffer.

if path == "/logread.txt" and is_development():
    http_ok()
    sys.stdout.flush()
    os.execlp("pts-logs", "pts-logs")

if path == "/logread.txt.gz" and is_development(): # same but compressed
    http_ok("application/x-gzip")
    sys.stdout.flush()
    os.execl("/bin/sh", "sh", "-c", "pts-logs | gzip")

if path == "/logread.dat":      # same but encrypted
    http_ok("application/octet-stream")
    sys.stdout.flush()
    os.execl("/bin/sh", "sh", "-c", "encrypt-logs pts-logs | gzip")

http_redirect(path, "/logread", "/logread.dat")

# ----------------------------------------------------------------------------
# View miscellaneous system status information.

if path == "/pts.txt" and is_development():
    http_ok()
    sys.stdout.flush()
    os.execlp("pts-info", "pts-info")

if path == "/pts.dat":          # same but encrypted
    http_ok("application/octet-stream")
    sys.stdout.flush()
    os.execlp("/bin/sh", "sh", "-c", "encrypt-logs pts-info | gzip")

http_redirect(path, "/pts", "/pts.dat")

# ----------------------------------------------------------------------------
# View network status information.

if path == "/network.txt" and is_development():
    http_ok()
    sys.stdout.flush()
    os.execlp("network-info", "network-info")

if path == "/network.dat":
    http_ok("application/octet-stream")
    sys.stdout.flush()
    os.execlp("/bin/sh", "sh", "-c", "encrypt-logs network-info | gzip")

http_redirect(path, "/network", "/network.dat")

# ----------------------------------------------------------------------------
# Force the system into reflash mode (QFIL).

if path == "/reflash":
    only_for_usb()

    http_ok("text/html")
    print """\
<html>
<head>
<title>Reflash Mode</title>
<style type="text/css">
 body {
   font-family: Verdana, Arial, Helvetica, sans-serif;
 }
</style>
</head>
<body>
<h1>Entering Reflash Mode</h1>
<p>Please wait.
</body>
</html>
"""
    sys.stdout.flush()

    # Sleep to give the output a chance to get out.
    subprocess.call("""(
  exec >&2;
  sleep 3;
  PlatformResetIntoQfil
) &""", shell=True)
    sys.exit()

# ----------------------------------------------------------------------------
# Get Bose version

if path == "/bose-version":
    only_for_usb()

    http_ok()
    sys.stdout.write(open("/opt/Bose/etc/BoseVersion.json").read())
    sys.exit()

# ----------------------------------------------------------------------------
# Get Riviera version

if path == "/kernel-version":
    only_for_usb()

    http_ok()
    sys.stdout.write(open("/etc/riviera-version").read())
    sys.exit()

# ----------------------------------------------------------------------------
# Validate manufacturing data

if path == "/validate-mfgdata":
    only_for_usb()

    http_ok()
    redirect_stderr()
    if subprocess.call(["validate-mfgdata"]) == 0:
        print "Valid Manufacturing Data."
    else:
        print "Invalid Manufacturing Data."
    sys.exit()

# ----------------------------------------------------------------------------
# Get LPM controller version

if path == "/controller-version":
    only_for_usb()

    http_ok()
    redirect_stderr()
    subprocess.call(["ReadLpmVersion"])
    sys.exit()

# ----------------------------------------------------------------------------
# Clear the "first greeting" flag.

if path == "/clear-first-greeting":
    only_for_usb()

    http_ok()
    try:
        os.remove("/mnt/nv/product-persistence/FirstBootGreetingDone")
        print "Cleared first greeting."
        subprocess.call(["sync"])
    except OSError, e:
        if e.strerror == "No such file or directory":
            print "The first greeting was already cleared."
        else:
            print "Unable to clear first greeting:", e.strerror

    sys.exit()

# ----------------------------------------------------------------------------
# Open source license documents.
# The customer end-user documentation references this URL path.

http_redirect(path.lower(), "/opensource", "/licenses.txt")
http_redirect(path.lower(), "/opensource/", "/licenses.txt")

# ----------------------------------------------------------------------------
# Remanufacturing.

if path == "/service" or path.startswith("/service?"):
    prog = "/opt/Bose/etc/service"
    os.execv(prog, [prog, path[len("/service?"):]])

# ----------------------------------------------------------------------------
# Development links.

if path == "/dev" and is_development():
    http_ok("text/html")
    print """\
<html>
<head>
<title>Development Links</title>
<style type="text/css">
 body {
   font-family: Verdana, Arial, Helvetica, sans-serif;
 }
 td {
   padding: 3px;
 }
 tr.even {
   background-color: lightgrey;
 }
 span.error {
   color: red;
 }
 td.iface {
   text-align: center;
 }
</style>

<script>

function set_address() {
  var ain = document.getElementById("address");
  var address = ain.value.trim();
  var err = "";
  if (address.match(/^[-\w.]+$/)) {
    var anchors = document.getElementsByTagName("a");
    for (var i = anchors.length; --i >= 0;) {
      a = anchors[i];
      a.href = "http://" + address + a.text;
    }
  }
  else {
    err = "(malformed)";
  }
  document.getElementById("error").textContent = err;
  ain.setSelectionRange(0, ain.value.length);
}

</script>
</head>
<body onload="set_address()">
<h1>Development Links</h1>
"""

    print """\
<p>
Address:
<input type="text" id="address" value="{local_address}" onchange="set_address()">
<span class="error" id="error"/>
""".format(local_address=os.environ.get("LOCAL_ADDRESS", ""))

    print """\
<p>
<table>
  <tr>
    <th>Interface</th>
    <th>Endpoint</th>
    <th>Description</th>
  </tr>
  <tr class="even">
    <td class="iface">usb</td>
    <td><a>/diag</a></td>
    <td>Quality Audit</td>
  </tr>
  <tr class="odd">
    <td class="iface">any</td>
    <td><a>/logread.txt</a></td>
    <td>A snapshot of the system log ring buffer*</td>
  </tr>
  <tr class="even">
    <td class="iface">any</td>
    <td><a>/logread.txt.gz</a></td>
    <td>Same as /logread.txt but compressed*</td>
  </tr>
  <tr class="odd">
    <td class="iface">any</td>
    <td><a>/pts.txt</a></td>
    <td>Various Linux and system status information (e.g., ifconfig)*</td>
  </tr>
  <tr class="even">
    <td class="iface">any</td>
    <td><a>/pts.dat</a></td>
    <td>Same as /pts.txt but encrypted</td>
  </tr>
  <tr class="odd">
    <td class="iface">any</td>
    <td><a>/logread.dat</a></td>
    <td>Same as /logread.txt but encrypted</td>
  </tr>
  <tr class="even">
    <td class="iface">usb</td>
    <td><a>/reflash</a></td>
    <td>Force the unit into reflash mode (QFIL)</td>
  </tr>
  <tr class="odd">
    <td class="iface">usb</td>
    <td><a>/bose-version</a></td>
    <td>/opt/Bose/etc/BoseVersion.json</td>
  </tr>
  <tr class="even">
    <td class="iface">usb</td>
    <td><a>/kernel-version</a></td>
    <td>/etc/riviera-version</td>
  </tr>
  <tr class="odd">
    <td class="iface">usb</td>
    <td><a>/validate-mfgdata</a></td>
    <td>Check the manufacturing data</td>
  </tr>
  <tr class="even">
    <td class="iface">usb</td>
    <td><a>/controller-version</a></td>
    <td>The LPM version strings</td>
  </tr>
  <tr class="odd">
    <td class="iface">usb</td>
    <td><a>/clear-first-greeting</a></td>
    <td>Clear the flag indicating the unit's first boot</td>
  </tr>
  <tr class="even">
    <td class="iface">any</td>
    <td><a>/opensource</a></td>
    <td>The licenses of open source software used in the system</td>
  </tr>
  <tr class="odd">
    <td class="iface">any</td>
    <td><a>/service</a></td>
    <td>Remanufacturing. Only in service mode</td>
  </tr>
  <tr class="even">
    <td class="iface">usb, wlan1</td>
    <td><a>/</a>, <a>/index.html</a></td>
    <td>Wi-Fi setup</td>
  </tr>
</table>

<p>
* Only in development mode.

</body>
</html>
"""
    sys.exit()

# ----------------------------------------------------------------------------
# Serve static content.

# Discard any query parameters from paths like
# "/index.html?deeplink=com.bose.myApp&ssid=myNetwork&context=ApSetup".
# See https://github.com/BoseCorp/bose-web-riviera-ap-page/
i = path.find("?")
if i != -1:
    path = path[:i]

if path == "/":
    path = "/index.html"

if path == "/index.html":
    # Wi-Fi setup page access is restricted to certain interfaces
    only_for_ifaces(["wlan1"] + usb_ifaces)

file_name = "/opt/Bose/html" + path

# Avoid possible security issues with paths like ../../etc/passwd and symlinks.
if file_name != os.path.realpath(file_name):
    http_err()
    sys.exit()

content_types = {
    ".html": "text/html",
    ".jpg": "image/jpeg",
    ".pdf": "application/pdf",
    ".svg": "image/svg+xml",
    ".ico": "image/x-icon",
}
content_type = "text/plain"
for ext, ctype in content_types.iteritems():
    if file_name.endswith(ext):
        content_type = ctype
        break

try:
    with open(file_name) as fh:
        http_ok(content_type)

        while True:
            buf = fh.read(4096)
            if not buf:
                break
            sys.stdout.write(buf)
    log("Sent {} ({})".format(file_name, content_type))
except IOError, exc:
    log("open " + file_name + ": " + exc.strerror)
    http_err()
sys.exit()

# ----------------------------------------------------------------------------
