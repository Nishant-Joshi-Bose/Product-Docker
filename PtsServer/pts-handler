#!/usr/bin/python2.7
#
# Invoked by PtsServer for each HTTP client connection.
# HTTP request headers and payload are to be read from stdin.
# HTTP response headers and payload are to be written to stdout.
#
import os
import sys

debug = False

def log(*args):
    print >>sys.stderr, "pts-handler:", " ".join(map(lambda a: str(a), args))

if len(sys.argv) != 1:
    raise Exception("wrong usage " + str(sys.argv))

line = sys.stdin.readline()
if not line:
    if debug:
        log("No header")
    sys.exit()

# `line` is like: "GET /hello/world.zip HTTP/1.1\r\n"
line = line.rstrip("\r\n")
fields = line.split(" ")
if len(fields) != 3:
    log("Malformed first header line", repr(fields))
    sys.exit()
method, path, version = fields

if debug:
    log("method '{}', path '{}', version '{}'".format(method, path, version))

# Read the HTTP headers
while True:
    line = sys.stdin.readline()
    if not line:
        if debug:
            log("EOF")
        sys.exit()
    line = line.rstrip("\r\n")
    if line == "":
        break
    if debug:
        log("header '{}'".format(line))

if method == "GET":

# ----------------------------------------------------------------------------
# Quality Audit CGI pages.

    if path == "/qaudit":
        print """\
HTTP/1.1 301 Moved Permanently\r
Location: /qaudit/\r
\r
Moved Permanently\r
"""
        sys.exit()

    if path.startswith("/qaudit/"):
        path = path[8:]
        if path == "":
            path = "main"
        prog = path
        args = []
        i = path.find("/")
        if i != -1:
            args.append(path[i+1:])
            prog = path[:i]
        log("qaudit", prog, args)
        os.chdir("/opt/Bose/qaudit")
        sys.stdout.flush()
        os.execv(prog, [prog] + args)

# ----------------------------------------------------------------------------

    if path == "/logread.txt":
        print """\
HTTP/1.1 200 OK\r
Content-Type: text/plain\r
Cache-Control: no-cache\r
\r"""
        sys.stdout.flush()
        os.execl("/sbin/logread", "logread")

    if path == "/logread.txt.gz":
        print """\
HTTP/1.1 200 OK\r
Content-Type: application/x-gzip\r
Cache-Control: no-cache\r
\r"""
        sys.stdout.flush()
        os.execl("/bin/sh", "sh", "-c", "logread | gzip")

    if path == "/pts.txt":
        import subprocess

        def call(*args):
            print ">", " ".join(args)
            sys.stdout.flush()
            subprocess.call(args, stderr=subprocess.STDOUT)

        print """\
HTTP/1.1 200 OK\r
Content-Type: text/plain\r
Cache-Control: no-cache\r
\r"""
        os.dup2(sys.stdout.fileno(), sys.stderr.fileno()) # redirect stderr to stdout
        call("date")
        call("cat", "/opt/Bose/etc/BoseVersion.json")
        call("free", "-m")
        call("ifconfig", "-a")
        call("ip", "route", "list")
        call("wpa_cli", "status")
        call("wpa_cli", "scan_results")
        call("sh", "-c", "head -100 /mnt/nv/product-persistence/* /mnt/nv/BoseApp-Persistence/1/*")
        call("ls", "-lHt", "/mnt/nv/BoseLog")
        call("ps")
        sys.exit()

    # Avoid possible security issues with paths like ../../etc/passwd
    if ".." not in path:
        if path == "/":
            path = "/index.html"
        file_name = "/opt/Bose/html" + path

        content_types = {
            ".html": "text/html",
            ".jpg": "image/jpeg",
            ".js": "text/plain",
            ".pdf": "application/pdf",
            ".svg": "image/svg+xml",
            ".txt": "text/plain",
        }
        content_type = None
        for ext, ctype in content_types.iteritems():
            if file_name.endswith(ext):
                content_type = ctype
                break

        try:
            with open(file_name) as fh:
                print "HTTP/1.1 200 OK\r"
                if content_type:
                    print "Content-Type: " + content_type + "\r"
                print "\r"

                while True:
                    buf = fh.read(4096)
                    if not buf:
                        break
                    sys.stdout.write(buf)
            log("Sent {} ({})".format(file_name, content_type))
            sys.exit()
        except IOError, exc:
            log("open " + file_name + ": " + exc.strerror)

print """\
HTTP/1.1 404 Not Found\r
Content-Type: text/plain\r
\r
404 Not Found\r"""
