#!/bin/bash
#
# Create an IPK file for installing minimal SoundTouch image for recovery.
#
# To install:
#   opkg install recovery.ipk
#
# To uninstall:
#   opkg remove recovery
#
this=${0##*/} # this script's name

cfg=Release

tryhelp () {
    echo >&2 "Try '$this --help' for more information."
    exit 1
}
opts=$(getopt --name "$this" --shell sh \
    -o hp: \
    -l "help,product:" \
    -- "$@") || tryhelp
eval set -- "$opts"
while :; do
    arg="$1"; shift
    case "$arg" in
	(--help | -h)
	    cat <<EOF
Usage: $this [options]

Create recovery package for given product type.

Options:
    -p <Product Type e.g. eddie / professor / flipper / taylor> - Product type to use
    -h - Print help
EOF
	    exit 0
	    ;;
    (--product | -p)
        product_type="$1"; shift
        ;;
    (--) break ;;
	(*)  echo >&2 "$this: internal error at '$arg'"; exit 1 ;;
    esac
done

if (( $# != 0 )); then
    echo >&2 "$this: unexpected argument '$1'"
    tryhelp
fi

if [ -z "$product_type" ]; then
    echo >&2 "$this: -p or --product is mandatory argument"
    tryhelp
fi

function put_script {
    local file="$1"; shift
    cat "$@" >"$file" || exit
    chmod 755 "$file" || exit
}

here=$(cd "$(dirname $0)" && echo "$PWD") || exit
wspace=$(cd "$here/.." && echo "$PWD") || exit

riviera_toolchain_dir=$(components get Riviera-Toolchain installed_location) || exit
rivierarecovery_dir=$(components get RivieraSwUpRecovery-qc8017_32 installed_location) || exit
minimalfs_dir=$(components get RivieraMinimalFS-qc8017_32 installed_location) || exit

sysroot=$riviera_toolchain_dir/sdk/sysroots/$(uname -m)-oesdk-linux
tool_prefix=$sysroot/usr/bin/arm-oemllib32-linux/arm-oemllib32-linux-
tool64_prefix=$sysroot/usr/bin/aarch64-oe-linux/aarch64-oe-linux-

stage=$wspace/builds/$cfg/recovery-ipk-stage
rm -rf "$stage"
echo "Stage directory $stage"

output_dir=$wspace/builds/$cfg
opt_dir=$stage/Bose
mkdir -p "$output_dir" "$opt_dir/etc" "$opt_dir/bin" || exit

components record "$stage" || exit

# copy minimal image tar to /opt/Bose
minimal_image="$minimalfs_dir"/RivieraMinimalFS_"$product_type".tar.gz
cp "$minimal_image"  "$opt_dir/" || exit

# copy recovery images from RivieraSwUpRecovery
"$rivierarecovery_dir/stage" "$opt_dir" || exit

PackageName=SoundTouchRecovery

#  @todo: CASTLE-28938 -  As of now, keep version same as product, but this should be minimalFS
# version. Also, Restore should become separate IPK with its own version
version_json=$wspace/builds/$cfg/qc8017_32/BoseVersion.json
package_version=$(make-version-string "$version_json" "{major}.{minor}.{patch}.{build_number}+{abbrev_commit}") || exit
echo "Package version \"$package_version\""
"$wspace"/scripts/validate-version "$package_version" || exit

cat >"$stage/control" <<EOF || exit
Package: $PackageName
Version: $package_version
Description: SoundTouch recovery version $package_version
 The SoundTouch recovery app
Section: soundtouch
Priority: optional
License: Commercial
Architecture: armv7a-vfp-neon
OE: soundtouch
Homepage: http://www.bose.com/
#Depends: libc6 (>= 2.21)
Source: None
EOF

# Installer scripts
put_script "$stage/postinst" <<EOF
#!/bin/sh
echo "SoundTouch recovery postinst"

if ! [ "\$(awk '\$2 == "/cache"' /proc/mounts)" ]; then
    echo "Mounting Cache"
    mount /dev/block/bootdevice/by-name/cache /cache || exit
fi

# To increase the cache partition size, reflash it
# Todo: Remove this block of code as soon as new HSP with
#   proper /cache partition size is released (remove after SOS)
##########################################################

if [ "\$(df | awk '\$6 == "/cache" {print \$2}')" -le 58888 ]; then

    # unmount /cache partition
    umount /cache || exit

    # reflash it
    mkfs.ext4 /dev/block/bootdevice/by-name/cache || exit

    echo "Mounting Cache after reflash"
    mount /dev/block/bootdevice/by-name/cache /cache || exit
fi

##########################################################

# Remove old logs
rm -f /cache/recovery/last_log.*
rm -f /cache/recovery/last_kmsg.*

# move minimal product image to cache partition
mv /opt/Bose/RivieraMinimalFS_*.tar.gz /cache/Bose_minimal.tar.gz || exit

# move RecoveryMain binary to /cache partition
mv /opt/Bose/bin/RecoveryMain /cache/ || exit
mv /opt/Bose/etc/RecoveryMgr /cache/ || exit

# Set Progress End
/opt/Bose/bin/ProgressReport -n $PackageName -e 0 -i 0 -r LPM -b 0 -p 100

exit 0
EOF

put_script "$stage/postrm" <<EOF
#!/bin/sh
echo "SoundTouch recovery postrm"
exit 0
EOF

put_script "$stage/preinst" <<EOF
#!/bin/sh
echo "SoundTouch recovery preinst"
# Set Progress Start
/opt/Bose/bin/ProgressReport -n $PackageName -e 0 -i 0 -r LPM -b 0 -p 1
exit 0
EOF

put_script "$stage/prerm" <<EOF
#!/bin/sh
echo "SoundTouch recovery prerm"
exit 0
EOF

# Our standard CentOS configuration has
# LD_LIBRARY_PATH=/usr/local/lib:/usr/lib:/lib which causes
# ${tool64_prefix}strip to segfault.  As a workaround, unset LD_LIBRARY_PATH
# here and hope it wasn't actually needed for anything else this script does.
if [ "$LD_LIBRARY_PATH" ]; then
    echo "$this: unsetting LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
    unset LD_LIBRARY_PATH
fi

for i in "$stage"/Bose/{lib,bin}/*; do
    type=$(file --brief "$i") || exit
    case "$type" in
        (*", stripped")
            echo >&2 "$this: (warning) No debug symbols: $i"
            ;;
        (*", ARM aarch64, "*", not stripped" | *" 64-bit "*", not stripped")
            # `strip` fails without an error message if the file is empty
            if ! "${tool64_prefix}strip" "$i"; then
                echo >&2 "$this: Failed to strip $i"
                exit 1
            fi
            ;;
        (*", not stripped")
            # `strip` fails without an error message if the file is empty
            if ! "${tool_prefix}strip" "$i"; then
                echo >&2 "$this: Failed to strip $i"
                exit 1
            fi
            ;;
    esac
done
# -----------------------------------------------------------------------------
# Stage area is complete.  Package it into a *.ipk file.

cd "$stage" || exit
tar --owner=0 --group=0 -czf control.tar.gz control pre* post* || exit
tar --owner=0 --group=0 -czf data.tar.gz -C "$opt_dir" . || exit
echo "2.0" > debian-binary || exit

ipk=$output_dir/recovery.ipk
rm -f "$ipk"
ar -crf "$ipk" control.tar.gz data.tar.gz debian-binary || exit
echo "Created $ipk"

# /cache partition used to put contents of this IPK is limited in size.
# Check if IPK is so big that /cache will become 100% and eventually cause
# softwareupdate failure. This prevents issues from happening in field
if [ $(stat -c "%s" "$ipk") -ge 104857600 ]; then
    echo >&2 "$this: IPK $ipk >= 100MB"
    exit 1
fi

exit 0
