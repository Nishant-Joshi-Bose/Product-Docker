#!/usr/bin/python2.7
# ################# NOTICE ###################
# This script is deprecated and will not work as expected.
# Please contact CastleSoftwareUpdate team know in case you need to use this functionality.
# ################# ###### ###################
# This script is intended to push locally built files to target without performing software update
# It uses ADB interface to push files and pushes only if the file has been updated
#

import argparse
import hashlib
import json
import os
import sys
import subprocess

from enum import Enum


workspace_base = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
target_device = ""  # hold ADB device ID
metadata_configuration = os.path.join(workspace_base, "scripts/push-to-target-metadata.json")  # configuration metadata

src_file_list = []  # list of files to be pushed
dest_file_list = []  # destination path against each source file in src_file_list


def exit_error():
    '''
    In case of error revert_all_configuration and exit

    :return: None
    '''
    revert_all_configuration()
    sys.exit(1)

def md5(fname):
    '''
    Calculate MD5 HASH of the file provided

    :param fname: full file path to calculate MD5 hash
    :return: MD5 hash
    '''
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()


def set_ADB_device(deviceID = None):
    '''
    Checks for available ADB devices and gives error if multiple found
    If deviceID id provided and matches in the list of available devices it will set it as target device

    :param deviceID: device ID to push files to
    :return: None
    '''
    global target_device

    subprocess.check_output(["adb", "start-server"])
    devices = subprocess.check_output(["adb", "devices"])

    if 'unauthorized' in devices or 'permissions' in devices:
        print "start ADB server with root privileges"
        sys.exit(1)

    devices = devices.partition('\n')[2].replace('device', '').split()

    if not devices:
        print "ERROR : No devices found on ADB"
        sys.exit(1)

    if deviceID:
        if deviceID in devices:
            target_device = deviceID
            return
        else:
            print "ERROR : Specified device ID did not match with available ADB devices"
            sys.exit(1)
    else:
        if len(devices) == 1:
            target_device = devices[0]
            return
        else:
            print "ERROR : Multiple devices found on ADB"
            sys.exit(1)


def ADB_push_file(src, dst):
    '''
    pushes src to dst

    :param src: file or directory to push to device
    :param dst: destination file or directory
    :return: 0 if success, error code otherwise
    '''

    command = 'adb -s ' + target_device + ' push ' + src + ' ' + dst
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    process.wait()

    if process.returncode:
        print "Error pushing file to target"

    return process.returncode


def ADB_execute_cmd(cmd):
    '''
    Execute command on adb shell

    :param cmd: command to be executed on device
    :return: output of the command executed
    '''
    command = 'adb -s ' + target_device + ' shell ' + cmd

    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    (out, err) = process.communicate()
    process.wait()

    return out


def prepare_device_for_push():
    '''
    This function will perform following operation required for push operation
    1. remount the partition as read write
    2. set the mfg dr flag value to 01 so that LPM do not restart device while pushing files
    3. Stop all services

    :return: None
    '''
    bash_script_name = '/tmp/setMFGDR01.sh'

    ADB_execute_cmd('/opt/Bose/bin/rw')

    with open(bash_script_name, "wb") as outFile:
        outFile.write('#/bin/bash\n')
        outFile.write('echo lpm pt \\\"mfg dr,01\\\" | nc 0 17000\n')

    result = ADB_push_file(bash_script_name, bash_script_name)
    if result:
        exit_error()

    add_execute_permission = 'chmod +x ' + bash_script_name
    ADB_execute_cmd(add_execute_permission)

    ADB_execute_cmd(bash_script_name)

    print "INFO : Stopping all services"
    ADB_execute_cmd('/opt/Bose/bin/stop')

    os.remove(bash_script_name)


def revert_all_configuration():
    '''
    In Failure / Success case perform following operations
    1. remount the partition as read only
    2. Start LPMService and CLIServer (so that we can communicate to LPM)
    3. set the mfg dr flag value to 00 so that LPM restart the device if heartbeat fails

    :return: None
    '''
    print "INFO : Post processing"
    bash_script_name = '/tmp/setMFGDR00.sh'

    with open(bash_script_name, "wb") as outFile:
        outFile.write('#/bin/bash\n')
        outFile.write('/opt/Bose/bin/LPMService &\n')
        outFile.write('/opt/Bose/bin/CLIServer &\n')
        outFile.write('sleep 3\n')
        outFile.write('echo lpm pt \\\"mfg dr,00\\\" | nc 0 17000\n')
        outFile.write('killall LPMService CLIServer &\n')

    result = ADB_push_file(bash_script_name, bash_script_name)
    if result :
        print "ERROR : Failed to push file : ", bash_script_name
        sys.exit(1)

    add_execute_permission = 'chmod +x ' + bash_script_name
    ADB_execute_cmd(add_execute_permission)

    # this will remount the partition as read only
    ADB_execute_cmd('/opt/Bose/bin/rw --read-only')

    # NOTICE NOTICE NOTICE
    # Below command is not working so user will have to manually restart all services
    # print "Starting all services"
    # ADB_execute_cmd('/opt/Bose/bin/SoundTouch start')

    ADB_execute_cmd(bash_script_name)

    os.remove(bash_script_name)


class pushReqType(Enum):
    push_all = 1
    push_module = 2
    push_binary = 3
    push_library = 4
    push_config = 5


def prepare_list_of_files_to_push(datastore, request_type, list_values):
    '''
    Uses datastore and prepares list of file name with full file path to push to device
    It also prepares the destination path list for all files in src list

    :param datastore: JSON datastore of the metadata configuration file
    :param request_type: Enumeration for push type given by user
    :param list_values: list of modules/binaries/configuration files
    :return: None
    '''

    global src_file_list
    global dest_file_list

    module_title = 'modules'
    src_path_title = 'src_path'
    dest_path_title = 'dest_path'

    try:
        for major in datastore.keys():
            for component in datastore[major][module_title].keys():

                # skip component if push request is for module and current component is not in modules list
                if request_type == pushReqType.push_module:
                    if component not in list_values:
                        if major not in list_values:
                            continue

                bins = datastore[major][module_title][component].get('bins')
                conf = datastore[major][module_title][component].get('conf')
                libs = datastore[major][module_title][component].get('libs')


                if request_type == pushReqType.push_all or request_type == pushReqType.push_binary or request_type == pushReqType.push_module:
                    # split the files by comma and prepare list of files
                    if bins:
                        s_path = datastore[major][src_path_title].get('bins')
                        s_path = os.path.join(workspace_base, s_path)
                        d_path = datastore[major][dest_path_title].get('bins')

                        bins = bins.split(",")
                        for index, fname in enumerate(bins):
                            if request_type == pushReqType.push_binary:
                                if fname.strip() in list_values:
                                    src_file_list.append(os.path.join(s_path, fname.strip()))
                                    dest_file_list.append(os.path.join(d_path, fname.strip()))
                            else :
                                src_file_list.append(os.path.join(s_path, fname.strip()))
                                dest_file_list.append(os.path.join(d_path, fname.strip()))

                if request_type == pushReqType.push_all or request_type == pushReqType.push_library or request_type == pushReqType.push_module:
                    if libs:
                        s_path = datastore[major][src_path_title].get('libs')
                        s_path = os.path.join(workspace_base, s_path)
                        d_path = datastore[major][dest_path_title].get('libs')

                        libs = libs.split(",")
                        for index, fname in enumerate(libs):
                            if request_type == pushReqType.push_library:
                                if fname.strip() in list_values:
                                    src_file_list.append(os.path.join(s_path, fname.strip()))
                                    dest_file_list.append(os.path.join(d_path, fname.strip()))
                            else :
                                src_file_list.append(os.path.join(s_path, fname.strip()))
                                dest_file_list.append(os.path.join(d_path, fname.strip()))

                if request_type == pushReqType.push_all or request_type == pushReqType.push_config or request_type == pushReqType.push_module:
                    if conf:
                        s_path = datastore[major][src_path_title].get('conf')
                        s_path = os.path.join(workspace_base, s_path)
                        d_path = datastore[major][dest_path_title].get('conf')

                        conf = conf.split(",")
                        for index, fname in enumerate(conf):
                            if request_type == pushReqType.push_config:
                                if fname.strip() in list_values:
                                    src_file_list.append(os.path.join(s_path, fname.strip()))
                                    dest_file_list.append(os.path.join(d_path, fname.strip()))
                            else :
                                src_file_list.append(os.path.join(s_path, fname.strip()))
                                dest_file_list.append(os.path.join(d_path, fname.strip()))

    except KeyError:
        print('Error : Module not found in metadata configuration file.')
        sys.exit(1)


def sync_files(src_list, dest_list):
    '''
    Pushes file to target only if there is any change
    :param file_path: Source directory to be synced
    :return: None
    '''

    for index, file in enumerate(src_list):
        if os.path.islink(file):
            # ignore symlinks
            continue

        elif os.path.isfile(file):
            # push file if md5sum mismatch
            dest_path = dest_list[index]
            src_md5 = md5(file)
            dest_md5 = ADB_execute_cmd('md5sum ' + dest_path).split(' ')[0]
            if src_md5 != dest_md5:
                print("Copying file : ", file)
                ADB_push_file(file, dest_path)

        elif os.path.isdir(file):
            # if directory iterate through it
            for filename in os.listdir(file):
                src_file = [os.path.join(file, filename)]
                dest_file = [os.path.join(dest_list[index], filename)]
                sync_files(src_file, dest_file)

        else:
            print "Error : File not found OR Unknown file type : ", file
            exit_error()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Push locally built files - specified by their name / module, to target via ADB. '
                                                 '   E.g. To copy all binaries for SoftwareUpdate: ./scripts/push-to-target -m SoftwareUpdate'
                                                 'OR E.g.  To copy only SoftwareUpdateService: ./scripts/push-to-target -b SoftwareUpdateService')
    parser.add_argument('-a', '--all',
                        default = False,
                        action = 'store_true',
                        dest = 'copy_all',
                        help = 'push all modules to target',
                        required = False)
    parser.add_argument('-b', '--binary',
                        action='store',
                        nargs='+',
                        dest='binary',
                        help='push specified binary itself OR all binaries of specified module',
                        required=False)
    parser.add_argument('-c', '--config',
                        default=False,
                        nargs='+',
                        action='store',
                        dest='config',
                        help='push specified config file itself OR all binaries of specified module',
                        required=False)
    parser.add_argument('-i', '--id',
                        action='store',
                        help='specify the device id, if multiple devices are connected to host machine',
                        dest='deviceID',
                        required=False)
    parser.add_argument('-l', '--library',
                        action='store',
                        nargs='+',
                        dest='library',
                        help='push specified library itself OR all binaries of specified module',
                        required=False)
    parser.add_argument('-m', '--modules',
                        action='store',
                        dest='modules',
                        nargs='+',
                        help='push all files for specified modules files - including binaries, libraries and configuration files as per metadata',
                        required=False)
    parser.add_argument('-r', '--reset',
                        default=False,
                        action='store_true',
                        dest='reset',
                        help='restart device after push operation',
                        required=False)
    parser.add_argument('-s', '--show',
                        default=False,
                        action='store_true',
                        dest='show',
                        help='Only list files which will be copied',
                        required=False)


    args = parser.parse_args()

    if len(sys.argv) == 1 or (len(sys.argv) == 2 and args.show):
        # display help message when no args are passed.
        parser.print_help()
        sys.exit(1)

    # print("Target ADB Device ID: [%s], Copy all option [%s], Only show list and do not push [%s]" %(args.deviceID, args.copy_all, args.show))
    # print("Modules specified: {}".format(args.modules))
    # print("Binaries specified: {}".format(args.binary))
    # print("Libraries specified: {}".format(args.library))
    # print("Config files specified: {}".format(args.config))
    #
    # print "Reading configurations from ", metadata_configuration

    if os.path.isfile(metadata_configuration):
        with open(metadata_configuration, 'r') as f:
            datastore = json.load(f)
    else:
        print("Configuration metadata not found")
        sys.exit(1)

    set_ADB_device(args.deviceID)

    # prepare files list to be pushed to device using different command line options
    if args.copy_all:
        # Push all the files listed in metadata configuration
        prepare_list_of_files_to_push(datastore, pushReqType.push_all, None)
    if args.modules:
        # Push all the files from metadata configuration listed under specified modules
        prepare_list_of_files_to_push(datastore, pushReqType.push_module, args.modules)
    if args.binary:
        # Push all the specified binaries to device
        prepare_list_of_files_to_push(datastore, pushReqType.push_binary, args.binary)
    if args.library:
        # Push all the specified libraries to device
        prepare_list_of_files_to_push(datastore, pushReqType.push_library, args.library)
    if args.config:
        # Push all the specified configuration files to device
        prepare_list_of_files_to_push(datastore, pushReqType.push_config, args.config)

    # desplay the list of files prepared, based on command lines, and exit
    if args.show:
        print("Total files : %s" % len(src_file_list))
        for i,j in zip(src_file_list, dest_file_list):
            print i, j
        sys.exit(0)

    if len(src_file_list) == 0:
        print("ERROR : No files found from metadata configuration based on your request")
        sys.exit(1)

    # prepare device before push operation, includes read/write permission and stopping services
    prepare_device_for_push()

    print("INFO : pushing files")
    # copy files only if there is any change
    sync_files(src_file_list, dest_file_list)

    # revert all configuration we made for this operation
    revert_all_configuration()

    if args.reset:
        # restart terminal
        ADB_execute_cmd('reboot')
